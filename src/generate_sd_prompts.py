#!/usr/bin/env python
"""
Generate prompts for Stable Diffusion based on WordNet hierarchies.
This script uses hierarchy data from JSON files generated by generate_hierarchy.py.
"""
import os
import argparse
import json
from pathlib import Path

def add_prompt_weights(words, parentheses=False):
    """Add weights to words in prompt for composable diffusion."""
    if parentheses:
        weighted_words = [f'({words[0]})']
    else:
        weighted_words = [f'{words[0]}']
    for i,word in enumerate(words[1:]):
        weight = 1/(i+3)
        if parentheses:
            weighted_words.append(f'({word} :{weight:.2f})')
        else:
            weighted_words.append(f'{word} :{weight:.2f}')
    return weighted_words

def load_hierarchy_data(input_file):
    """Load hierarchy data from JSON file."""
    with open(input_file, 'r') as f:
        return json.load(f)

def generate_prompts(hierarchy_data, output_dir=None, custom_format=None, leaves_only=False, input_filename=None):
    """Generate prompts based on hierarchy data."""
    if not hierarchy_data:
        raise ValueError("No hierarchy data provided")
        
    # Get root category from first entry's last path element
    root_category = hierarchy_data[0]['path_names'][-1]  
    
    # Create output directories
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        # We no longer create a prompts subdirectory
    
    # Filter to leaves only if requested
    if leaves_only:
        # First, build a dictionary mapping synset_id to its children
        children = {}
        for item in hierarchy_data:
            synset_id = item['synset_id']
            children[synset_id] = []
        
        # Populate children lists
        for item in hierarchy_data:
            # Skip the root item
            if len(item['path_names']) <= 1:
                continue
                
            # Get the parent synset ID
            parent_path_name = item['path_names'][-2]  # Second last element is the parent
            parent_item = next((i for i in hierarchy_data if i['name'] == parent_path_name), None)
            
            if parent_item:
                parent_id = parent_item['synset_id']
                children[parent_id].append(item['synset_id'])
        
        # Identify leaf nodes (nodes with no children)
        leaf_synsets = [synset_id for synset_id, child_list in children.items() if not child_list]
        
        # Filter hierarchy data to keep only leaf nodes
        hierarchy_data = [item for item in hierarchy_data if item['synset_id'] in leaf_synsets]
        
        print(f"Filtered to {len(hierarchy_data)} leaf nodes")
    
    # Generate prompts for each entry
    prompt_data = []
    
    for item in hierarchy_data:
        # Extract data
        name = item['name']
        definition = item.get('definition', "")
        
        # Create weighted path for the prompt
        path_names = item['path_names']
        weighted_words = add_prompt_weights(path_names)
        
        # Create prompt based on format
        if custom_format == "dog":
            prompt = ' AND a '.join([f'a dog of breed {weighted_words[0]}, photograph'] + weighted_words[1:])
        elif custom_format == "building":
            prompt = ' AND a '.join([f'a building of type {weighted_words[0]}, photograph'] + weighted_words[1:])
        else:
            prompt = ' AND a '.join([f'a {weighted_words[0]}, photograph'] + weighted_words[1:])
        
        # Add definition to enrich the prompt
        prompt = f'{prompt} AND a {root_category}, {definition} :0.2'
        
        # Create prompt data entry
        prompt_entry = {
            'synset_id': item['synset_id'],
            'name': name,
            'prompt': prompt,
            'path': os.path.join(root_category, name) if output_dir else None
        }
        prompt_data.append(prompt_entry)
    
    # Save prompts to file
    if output_dir and input_filename:
        # Construct filename with leaves_only indicator if applicable
        filename_suffix = "_leaves_only_prompts.json" if leaves_only else "_prompts.json"
        output_file = os.path.join(output_dir, f"{input_filename}{filename_suffix}")
        with open(output_file, 'w') as f:
            json.dump(prompt_data, f, indent=2)
        print(f"Prompts saved to {output_file}")
    
    return prompt_data, root_category

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate prompts for Stable Diffusion based on WordNet hierarchy")
    parser.add_argument("input_file", help="Input JSON file containing hierarchy data")
    parser.add_argument("--output-dir", required=True, help="Output directory for generated files")
    parser.add_argument("--format", choices=["default", "dog", "building"], default="default",
                       help="Custom prompt format to use")
    parser.add_argument("--leaves-only", action="store_true", 
                       help="Generate prompts only for leaf nodes in the hierarchy")
    
    args = parser.parse_args()
    
    # Ensure input file is JSON
    input_file = args.input_file
    if not input_file.endswith('.json'):
        input_file = f"{input_file}.json"
        print(f"Assuming JSON input file: {input_file}")
    
    # Load hierarchy data
    hierarchy_data = load_hierarchy_data(input_file)
    
    # Get the input filename without directory or extension
    input_filename = os.path.splitext(os.path.basename(input_file))[0]
    output_dir = args.output_dir
    
    prompts, root_category = generate_prompts(
        hierarchy_data,
        output_dir=output_dir,
        custom_format=args.format if args.format != "default" else None,
        leaves_only=args.leaves_only,
        input_filename=input_filename
    )
    
    print(f"Generated {len(prompts)} prompts for concept '{root_category}'")
